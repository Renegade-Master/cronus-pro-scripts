/************************************************\
|                                                |
| GPC SCRIPT for preventing AFK from triggering. |
| Also features a Random Number Generator.       |
|                                                |
\************************************************/

// Constant values
int AIM_CHANCE;
int INT_MAX;
int MAX_AIM_TIME;
int NO_AIM_TIME;
int STRAFE_TIME;
int TURN_SPEED;
int WALK_TIME;

// Time management
int lastTime;
int runTime;

// Runtime variables
int currentlyAiming;
int lookToRight;
int randNum;
int runAntiAfk;


/*******************\
| Initialise Script |
\*******************/
init {
	AIM_CHANCE = 5;
	INT_MAX = 32767;
	MAX_AIM_TIME = 3500;
	NO_AIM_TIME = 10000;
	STRAFE_TIME = 4000;
	TURN_SPEED = 75;
	WALK_TIME = 7500;

	lastTime = 0;
	runTime = 0;

	currentlyAiming = FALSE;
	lookToRight = FALSE;
	randNum = 0;
	runAntiAfk = FALSE;
}


/***********\
| Main Loop |
\***********/
main {
	// Update runTime
	lastTime = runTime;
	runTime += get_rtime();

	set_val(TRACE_5, currentlyAiming);

	// Request to turn ON the macro
	if (event_press(PS4_TRIANGLE) && event_press(PS4_SQUARE)) {
		runAntiAfk = TRUE;
	}

	// Request to turn OFF the macro
	if (event_press(PS4_CIRCLE) && event_press(PS4_CROSS)) {
		runAntiAfk = FALSE;
		combo_stop(ANTI_AFK);
	}

	// If the macro should be ON
	if (runAntiAfk) {
		combo_run(ANTI_AFK);

		// Sometimes aim and look around
		if ((random_number(0, 100) < AIM_CHANCE) && !currentlyAiming) {
			combo_run(AIM_AND_LOOK);
		}
	} else { // If the macro should be OFF
		combo_stop(ANTI_AFK);
	}
}

/********\
| Combos |
\********/

/**
* Anti AFK Macro
*/
combo ANTI_AFK {
	// Walk forwards
	reset_movement();
	walk(TRUE);
	wait(WALK_TIME);

	// Walk left
	reset_movement();
	strafe(FALSE);
	wait(STRAFE_TIME);

	// Walk forwards
	reset_movement();
	walk(TRUE);
	wait(WALK_TIME);

	// Walk right
	reset_movement();
	strafe(TRUE);
	wait(STRAFE_TIME);
}


/**
* Aim and Look Macro
*/
combo AIM_AND_LOOK {
	currentlyAiming = TRUE;
	aim_and_look();

	wait(MAX_AIM_TIME);

	currentlyAiming = FALSE;
	reset_aim();

	wait(NO_AIM_TIME)
	lookToRight = !lookToRight;
}

/***********\
| Functions |
\***********/

/**
* Strafe to the side
*
* @param to_the_right Integer value representing strafe direction.
*/
function strafe(int to_the_right) {
	if (to_the_right) {
		set_val(PS4_LX, 100);
	} else {
		set_val(PS4_LX, -100);
	}
}


/**
* Walk
*
* @param forwards Integer value representing walk direction.
*/
function walk(int forwards) {
	if (forwards) {
		set_val(PS4_LY, -100);
	} else {
		set_val(PS4_LY, 100);
	}
}


/**
* Reset movement to stationary
*/
function reset_movement() {
	set_val(PS4_LX, 0);
	set_val(PS4_LY, 0);
}


/**
* Aim and look around
*/
function aim_and_look() {
	set_val(PS4_L2, 100);

	if (lookToRight) {
		set_val(PS4_RX, TURN_SPEED);
	} else {
		set_val(PS4_RX, inv(TURN_SPEED));
	}
}


/**
* Reset Aim and look direction
*/
function reset_aim() {
	set_val(PS4_L2, 0);
	set_val(PS4_RX, 0);
}

/****/

/**
* Pseudo Random Number Generator
*
*
* @param low Integer value representing minimum desired value.
* @param high Integer value representing maximum desired value.
*
* @return A random number between the specified HIGH and LOW values.
*/
function random_number(int low, int high) {
	//randNum = abs((lastTime * runTime) / (INT_MAX / ((high - low) + 1) + 1));
	randNum = abs(runTime % (high - low + 1) + low);

	// Debug random number
	set_val(TRACE_6, randNum);

	return randNum;
}
